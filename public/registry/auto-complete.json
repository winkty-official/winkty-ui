{
  "name": "auto-complete",
  "type": "registry:ui",
  "registryDependencies": [
    "button",
    "popover",
    "command",
    "badge"
  ],
  "dependencies": [
    "framer-motion",
    "lucide-react"
  ],
  "files": [
    {
      "type": "registry:ui",
      "content": "\"use client\";\n\nimport type React from \"react\";\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { motion } from \"framer-motion\";\nimport { Check, ChevronsUpDown, X } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\"; // Assuming this utility exists\nimport { Button } from \"@/components/ui/button\"; // Assuming these components exist\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/components/ui/command\";\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/components/ui/popover\";\nimport { Badge } from \"@/components/ui/badge\";\n\nexport type Option = {\n  value: string;\n  label: string;\n  [key: string]: unknown; // Allow additional properties\n};\n\ntype SingleSelectProps = {\n  multiSelect?: false;\n  value?: string | null; // Changed\n  onChange?: (value: string | null) => void; // Changed\n};\n\ntype MultiSelectProps = {\n  multiSelect: true;\n  value?: string[] | null; // Changed (allowing null for controlled clear)\n  onChange?: (value: string[]) => void; // Changed (returns empty array for no selection)\n};\n\ntype CommonProps = {\n  options?: Option[];\n  loadOptions?: (inputValue: string) => Promise<Option[]>;\n  placeholder?: string;\n  disabled?: boolean;\n  loading?: boolean;\n  error?: string;\n  className?: string;\n  size?: \"sm\" | \"md\" | \"lg\";\n  clearable?: boolean;\n  renderOption?: (option: Option) => React.ReactNode;\n  filterOption?: (option: Option, inputValue: string) => boolean;\n  name?: string;\n  onBlur?: () => void;\n  any?: boolean;\n};\n\ntype AutocompleteProps = CommonProps & (SingleSelectProps | MultiSelectProps);\n\nexport default function Autocomplete({\n  options: initialOptions = [],\n  value, // Now string | null or string[] | null\n  onChange, // Now (string | null)=>void or (string[])=>void\n  loadOptions,\n  placeholder = \"Select...\",\n  disabled = false,\n  loading: externalLoading = false,\n  error,\n  className,\n  size = \"md\",\n  clearable = true,\n  renderOption,\n  filterOption,\n  name,\n  multiSelect = false,\n  any = false,\n}: AutocompleteProps) {\n  const [open, setOpen] = useState(false);\n  const [options, setOptions] = useState<Option[]>(initialOptions);\n  const [query, setQuery] = useState(\"\");\n  const [internalLoading, setInternalLoading] = useState(false);\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const loading = externalLoading || internalLoading;\n\n  useEffect(() => {\n    if (!loadOptions) {\n      setOptions(initialOptions);\n    }\n  }, [initialOptions, loadOptions]);\n\n  const debouncedLoadOptions = useCallback(\n    async (inputValue: string) => {\n      if (loadOptions) {\n        setInternalLoading(true);\n        try {\n          const newOptions = await loadOptions(inputValue);\n          setOptions(newOptions);\n        } catch (e) {\n          console.error(\"Failed to load options:\", e);\n          setOptions(initialOptions); // Revert to initial or handle error state\n        } finally {\n          setInternalLoading(false);\n        }\n      }\n    },\n    [loadOptions, initialOptions], // Added initialOptions as a fallback\n  );\n\n  useEffect(() => {\n    if (loadOptions && query) { // Only call if query is not empty for loadOptions\n      const timer = setTimeout(() => {\n        debouncedLoadOptions(query);\n      }, 300);\n      return () => clearTimeout(timer);\n    } else if (!loadOptions) {\n      // For non-async, options are already set by initialOptions\n    } else {\n      // If loadOptions is present but query is empty, maybe reset to initialOptions or show specific message\n      setOptions(initialOptions);\n    }\n  }, [query, debouncedLoadOptions, loadOptions, initialOptions]);\n\n\n  const filteredOptions = useMemo(() => {\n    if (!query && !loadOptions) { // Show all options if query is empty and not using loadOptions\n      return options;\n    }\n    return filterOption\n      ? options.filter((option) => filterOption(option, query))\n      : options.filter((option) =>\n        option.label.toLowerCase().includes(query.toLowerCase()),\n      );\n  }, [options, query, filterOption, loadOptions]);\n\n\n  const currentDisplayOptions = useMemo(() => {\n    if (multiSelect) {\n      const currentValues = Array.isArray(value) ? value : [];\n      if (currentValues.length === 0) return [];\n\n      return currentValues\n        .map(valStr => {\n          const foundOption = options.find(opt => opt.value === valStr);\n          if (foundOption) return foundOption;\n          if (any) return { value: valStr, label: valStr };\n          return null;\n        })\n        .filter(Boolean) as Option[];\n    } else {\n      if (value && typeof value === 'string') {\n        const foundOption = options.find(opt => opt.value === value);\n        if (foundOption) return foundOption;\n        if (any) return { value: value, label: value };\n        return null;\n      }\n      return null;\n    }\n  }, [value, options, multiSelect, any]);\n\n  const handleCustomValue = useCallback(() => {\n    if (!query.trim()) return;\n    const customVal = query.trim();\n\n    if (multiSelect) {\n      const currentValues = Array.isArray(value) ? value : [];\n      if (!currentValues.includes(customVal)) {\n        const newValue = [...currentValues, customVal];\n        (onChange as (val: string[]) => void)?.(newValue);\n      }\n    } else {\n      (onChange as (val: string | null) => void)?.(customVal);\n      setOpen(false);\n    }\n    setQuery(\"\");\n  }, [query, multiSelect, value, onChange]);\n\n  const handleSelect = useCallback(\n    (optionToSelect: Option) => {\n      if (multiSelect) {\n        const currentValues = Array.isArray(value) ? value : [];\n        const valueSet = new Set(currentValues);\n        let newValue: string[];\n        if (valueSet.has(optionToSelect.value)) {\n          newValue = currentValues.filter(v => v !== optionToSelect.value);\n        } else {\n          newValue = [...currentValues, optionToSelect.value];\n        }\n        (onChange as (val: string[]) => void)?.(newValue);\n      } else {\n        (onChange as (val: string | null) => void)?.(optionToSelect.value);\n        setOpen(false);\n      }\n      setQuery(\"\");\n    },\n    [multiSelect, value, onChange],\n  );\n\n  const handleClear = useCallback(\n    (e?: React.MouseEvent) => {\n      e?.stopPropagation();\n      if (multiSelect) {\n        (onChange as (val: string[]) => void)?.([]);\n      } else {\n        (onChange as (val: string | null) => void)?.(null);\n      }\n      setQuery(\"\");\n      setOpen(false); // Close popover on clear\n    },\n    [onChange, multiSelect],\n  );\n\n  const handleKeyDown = useCallback(\n    (e: React.KeyboardEvent) => {\n      if (e.key === \"Enter\" && any && filteredOptions.length === 0 && query.trim()) {\n        e.preventDefault();\n        handleCustomValue();\n      } else if (e.key === \"Backspace\" && query === \"\") {\n        if (multiSelect && Array.isArray(value) && value.length > 0) {\n          const newValue = value.slice(0, -1);\n          (onChange as (val: string[]) => void)?.(newValue);\n        } else if (!multiSelect && value !== null) {\n          handleClear();\n        }\n      }\n    },\n    [any, filteredOptions.length, query, handleCustomValue, multiSelect, value, onChange, handleClear],\n  );\n\n  const handleRemoveOption = useCallback(\n    (optionToRemove: Option) => {\n      if (multiSelect && Array.isArray(value)) {\n        const newValue = value.filter(v => v !== optionToRemove.value);\n        (onChange as (val: string[]) => void)?.(newValue);\n      }\n    },\n    [multiSelect, value, onChange],\n  );\n\n  const renderValueDisplay = () => {\n    if (multiSelect) {\n      const displayBadges = currentDisplayOptions as Option[] | null; // Will be Option[]\n      return displayBadges && displayBadges.length > 0 ? (\n        <div className=\"flex flex-wrap items-center gap-1\">\n          {displayBadges.map((option) => (\n            <Badge\n              key={option.value}\n              variant=\"secondary\"\n              className=\"mr-1 group-hover:border group-hover:border-primary\"\n            >\n              {option.label}\n              <button // Changed to button for better accessibility\n                type=\"button\"\n                aria-label={`Remove ${option.label}`}\n                className=\"ml-1 rounded-full outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-background focus:ring-ring\"\n                onClick={(e) => {\n                  e.stopPropagation();\n                  handleRemoveOption(option);\n                }}\n                onKeyDown={(e) => { // Keep for completeness, though click is primary for buttons\n                  if (e.key === \"Enter\" || e.key === \" \") {\n                    e.stopPropagation();\n                    handleRemoveOption(option);\n                  }\n                }}\n              >\n                <X className=\"h-3 w-3 text-muted-foreground hover:text-foreground\" />\n              </button>\n            </Badge>\n          ))}\n        </div>\n      ) : (\n        <span className=\"text-muted-foreground\">{placeholder}</span>\n      );\n    }\n\n    const displaySingle = currentDisplayOptions as Option | null;\n    return displaySingle ? (\n      <div className=\"flex items-center gap-2\">\n        {renderOption ? renderOption(displaySingle) : displaySingle.label}\n      </div>\n    ) : (\n      <span className=\"text-muted-foreground\">{placeholder}</span>\n    );\n  };\n\n  const hasValue = multiSelect ? (Array.isArray(value) && value.length > 0) : (value !== null && value !== undefined);\n\n  return (\n    <div className=\"space-y-2\">\n      <Popover open={open} onOpenChange={setOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            ref={buttonRef}\n            variant=\"outline\"\n            role=\"combobox\"\n            aria-haspopup=\"listbox\"\n            aria-expanded={open}\n            className={cn(\n              \"w-full justify-between group\",\n              size === \"sm\" && \"h-auto py-1.5 text-sm\", // Adjusted padding for sm\n              size === \"md\" && \"h-10\", // Standard h-10 for md\n              size === \"lg\" && \"h-11\", // Standard h-11 for lg\n              error && \"border-destructive\",\n              className,\n              !hasValue && \"text-muted-foreground\", // Style placeholder text\n              \"h-auto min-h-10\" // Ensure it can grow with badges but has a min height\n            )}\n            disabled={disabled}\n            onClick={() => !disabled && setOpen((prev) => !prev)} // Prevent open if disabled\n          >\n            <div className=\"flex-1 text-left overflow-hidden whitespace-nowrap\">\n              {renderValueDisplay()}\n            </div>\n            <div className=\"flex items-center self-stretch\"> {/* Ensure icons align nicely */}\n              {clearable && hasValue && !disabled && (\n                <button // Changed to button for better accessibility\n                  type=\"button\"\n                  aria-label=\"Clear selection\"\n                  className=\"mr-2 h-4 w-4 shrink-0 opacity-50 hover:opacity-100 focus:outline-none\"\n                  onClick={handleClear}\n                  onKeyDown={(e) => {\n                    if (e.key === \"Enter\" || e.key === \" \") {\n                      e.preventDefault();\n                      handleClear(e as unknown as React.MouseEvent); // Keep for key interaction\n                    }\n                  }}\n                >\n                  <X />\n                </button>\n              )}\n              <ChevronsUpDown className=\"h-4 w-4 shrink-0 opacity-50\" />\n            </div>\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent\n          className=\"w-[--radix-popover-trigger-width] p-0\"\n          style={{ width: buttonRef.current?.offsetWidth }} // Ensure content width matches trigger\n          onOpenAutoFocus={(e) => e.preventDefault()} // Prevent auto-focus on first item, let input take focus\n        >\n          <Command>\n            <CommandInput\n              ref={inputRef}\n              placeholder={placeholder} // Use consistent placeholder\n              value={query}\n              onValueChange={(newQuery) => {\n                setQuery(newQuery);\n                if (!open && newQuery) setOpen(true); // Open if typing when closed\n              }}\n              onKeyDown={handleKeyDown}\n              onFocus={() => !open && setOpen(true)} // Open on focus\n            />\n            <CommandList>\n              <CommandEmpty>\n                {loading ? null : (any && query.trim() ? ( // Don't show \"add custom\" if loading\n                  <div className=\"p-2 text-sm text-center\">\n                    Press Enter to add &quot;{query}&quot;\n                  </div>\n                ) : (\n                  \"No results found.\"\n                ))}\n              </CommandEmpty>\n              <CommandGroup className=\"max-h-60 overflow-auto\">\n                {loading ? (\n                  <motion.div\n                    initial={{ opacity: 0 }}\n                    animate={{ opacity: 1 }}\n                    exit={{ opacity: 0 }}\n                    className=\"p-4 text-center text-sm text-muted-foreground\"\n                  >\n                    Loading...\n                  </motion.div>\n                ) : (\n                  filteredOptions.map((option) => (\n                    <CommandItem\n                      key={option.value}\n                      value={option.label} // Keep label for Command's internal filtering/navigation if needed\n                      onSelect={() => handleSelect(option)}\n                      className=\"flex items-center justify-between\"\n                      data-value={option.value} // Ensure value is available for testing/debugging\n                    >\n                      {renderOption ? renderOption(option) : option.label}\n                      <Check\n                        className={cn(\n                          \"ml-auto h-4 w-4\", // Use ml-auto to push check to the right\n                          (() => {\n                            let isChecked = false;\n                            if (multiSelect && Array.isArray(value)) {\n                              isChecked = value.some(v => v === option.value);\n                            } else {\n                              isChecked = value === option.value;\n                            }\n                            return isChecked ? \"opacity-100\" : \"opacity-0\";\n                          })()\n                        )}\n                      />\n                    </CommandItem>\n                  ))\n                )}\n              </CommandGroup>\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n      {error && (\n        <motion.p\n          initial={{ opacity: 0, y: -10 }}\n          animate={{ opacity: 1, y: 0 }}\n          className=\"text-sm text-destructive\"\n        >\n          {error}\n        </motion.p>\n      )}\n      {name && (\n        <input\n          type=\"hidden\"\n          name={name}\n          value={\n            multiSelect\n              ? JSON.stringify(Array.isArray(value) ? value : [])\n              : value ?? \"\"\n          }\n        />\n      )}\n    </div>\n  );\n}",
      "path": "ui/auto-complete.tsx",
      "target": "components/ui/auto-complete.tsx"
    }
  ]
}